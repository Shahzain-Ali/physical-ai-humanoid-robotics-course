# Data Model: RAG Chatbot

**Feature**: 002-rag-chatbot
**Created**: 2025-12-17
**Purpose**: Define all entities, their relationships, validation rules, and state transitions for the RAG chatbot feature.

## Overview

The RAG chatbot data model consists of four primary entities:
1. **Chat Session** - Conversation container (managed by OpenAI Agent SDK)
2. **Chat Message** - Individual messages in conversations (managed by OpenAI Agent SDK)
3. **Course Content Chunk** - Segmented course material for retrieval (stored in Qdrant)
4. **Source Citation** - Reference metadata (ephemeral, not persisted)

## Entity Definitions

---

### Entity 1: Chat Session

**Description**: Represents a conversation between a user and the chatbot. Automatically managed by OpenAI Agent SDK's `SQLAlchemySession`.

**Storage**: Neon Serverless Postgres (auto-managed by SQLAlchemySession)

**Schema** (Auto-generated by OpenAI Agent SDK):

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `id` | UUID | PRIMARY KEY, NOT NULL | Unique session identifier |
| `user_id` | String(255) | INDEXED, NOT NULL | Browser session ID or user identifier |
| `created_at` | Timestamp | NOT NULL, DEFAULT NOW() | Session creation time |
| `updated_at` | Timestamp | NOT NULL, DEFAULT NOW() | Last activity timestamp |
| `metadata` | JSONB | NULLABLE | Session context (e.g., device info) |

**Validation Rules**:
- `user_id` must be non-empty string (1-255 characters)
- Sessions auto-expire after 90 days of inactivity (retention policy)
- `metadata` must be valid JSON if present

**State Transitions**: N/A (sessions are stateless - created on first message, persisted indefinitely within retention window)

**Relationships**:
- **Has Many** Chat Messages (1:N relationship)
- One session contains zero or more messages
- Foreign key constraint from Chat Message to Chat Session

**Indexes**:
- Primary index on `id` (UUID)
- Secondary index on `user_id` (for retrieving user's sessions)
- Secondary index on `created_at` (for retention policy cleanup)

**Example**:
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "user_id": "browser_abc123",
  "created_at": "2025-12-17T10:00:00Z",
  "updated_at": "2025-12-17T10:15:00Z",
  "metadata": {
    "device": "desktop",
    "browser": "chrome"
  }
}
```

---

### Entity 2: Chat Message

**Description**: Represents a single message in a conversation (either from user or assistant). Automatically managed by OpenAI Agent SDK's `SQLAlchemySession`.

**Storage**: Neon Serverless Postgres (auto-managed by SQLAlchemySession)

**Schema** (Auto-generated by OpenAI Agent SDK):

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `id` | UUID | PRIMARY KEY, NOT NULL | Unique message identifier |
| `session_id` | UUID | FOREIGN KEY, NOT NULL | Reference to Chat Session |
| `role` | String(20) | NOT NULL, CHECK IN ('user', 'assistant') | Message sender |
| `content` | Text | NOT NULL, LENGTH 1-10000 | Message text |
| `created_at` | Timestamp | NOT NULL, DEFAULT NOW() | Message creation time |
| `metadata` | JSONB | NULLABLE | Optional data (e.g., selected_text) |

**Validation Rules**:
- `role` must be exactly "user" or "assistant"
- `content` must be 1-10,000 characters
- `session_id` must reference existing Chat Session
- `metadata.selected_text` (if present) must be string, max 5000 characters

**State Transitions**: N/A (messages are immutable once created)

**Relationships**:
- **Belongs To** one Chat Session (N:1 relationship)
- Foreign key `session_id` references `chat_sessions.id` with ON DELETE CASCADE

**Indexes**:
- Primary index on `id` (UUID)
- Foreign key index on `session_id` (for retrieving session messages)
- Composite index on `(session_id, created_at)` (for ordered retrieval)

**Example (User Message)**:
```json
{
  "id": "660e9500-f39c-52e5-b827-557766551111",
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "role": "user",
  "content": "What are ROS 2 nodes?",
  "created_at": "2025-12-17T10:05:00Z",
  "metadata": null
}
```

**Example (Assistant Message with Selected Text Context)**:
```json
{
  "id": "770f0611-g40d-63f6-c938-668877662222",
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "role": "assistant",
  "content": "ROS 2 nodes are independent processes that perform computation. Each node can publish and subscribe to topics...",
  "created_at": "2025-12-17T10:05:03Z",
  "metadata": {
    "sources": ["03-ros2.md", "03-ros2.md"],
    "selected_text": "rclpy is the Python client library for ROS 2"
  }
}
```

---

### Entity 3: Course Content Chunk

**Description**: Represents a segment of course material stored for semantic search and retrieval. Each chunk is a 500-1000 token segment of a course page with overlap for context preservation.

**Storage**: Qdrant Cloud (vector database)

**Schema** (Qdrant payload fields):

| Field | Type | Description |
|-------|------|-------------|
| `chunk_id` | String | Unique identifier: `{page}#{chunk_index}` (e.g., "03-ros2.md#0") |
| `text` | String | Actual content chunk (500-1000 tokens) |
| `embedding` | Vector[1536] | OpenAI `text-embedding-3-small` embedding |
| `page` | String | Source Markdown file (e.g., "03-ros2.md") |
| `section` | String | Markdown header title (e.g., "Understanding Nodes") |
| `url` | String | Full course URL with anchor (e.g., "/docs/03-ros2#understanding-nodes") |
| `chunk_index` | Integer | Zero-based position in page |
| `token_count` | Integer | Approximate tokens in chunk |
| `created_at` | String (ISO8601) | Timestamp when chunk was embedded |

**Validation Rules**:
- `text` must be 50-2000 tokens
- `embedding` must be exactly 1536 dimensions (OpenAI `text-embedding-3-small` format)
- `page` must match existing course file in `docs/` directory
- `url` must be valid course route (starts with "/docs/")
- `chunk_index` must be >= 0
- `token_count` must be positive integer

**Indexing**:
- **Primary Index**: Vector similarity (HNSW algorithm)
  - Distance metric: Cosine similarity
  - HNSW parameters: `m=16`, `ef_construct=100`
  - Optimized for 1536-dimensional vectors
- **Secondary Index**: Payload filter on `page` field (for filtering by source document)

**Chunking Strategy**:
- Split by Markdown headers (##, ###)
- Target size: 500-1000 tokens per chunk
- Overlap: 100 tokens between consecutive chunks (preserves context at boundaries)
- If section > 1000 tokens: split by paragraphs
- If paragraph > 1000 tokens: split by sentences

**Example**:
```json
{
  "chunk_id": "03-ros2.md#5",
  "text": "ROS 2 nodes are independent processes that perform computation. Each node typically represents a single, modular purpose: to control the robot's wheels, to publish sensor data, or to perform localization...",
  "embedding": [0.023, -0.011, 0.045, ..., 0.019],  // 1536 dimensions
  "page": "03-ros2.md",
  "section": "Understanding Nodes",
  "url": "/docs/03-ros2#understanding-nodes",
  "chunk_index": 5,
  "token_count": 742,
  "created_at": "2025-12-17T09:00:00Z"
}
```

**Collection Configuration** (Qdrant):
```python
{
  "collection_name": "book_content",
  "vectors": {
    "size": 1536,
    "distance": "Cosine"
  },
  "hnsw_config": {
    "m": 16,
    "ef_construct": 100
  },
  "optimizers_config": {
    "indexing_threshold": 10000
  }
}
```

---

### Entity 4: Source Citation

**Description**: Reference to course material included in a chatbot response. Ephemeral entity - not persisted to database, generated dynamically per response from Qdrant search results.

**Storage**: None (ephemeral, exists only in API response)

**Schema** (Pydantic model in Python):

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `page` | String | NOT NULL, LENGTH 1-255 | Source file name (e.g., "03-ros2.md") |
| `section` | String | NOT NULL, LENGTH 1-255 | Markdown section title (e.g., "Understanding Nodes") |
| `url` | String | NOT NULL, VALID URL | Full URL with anchor (e.g., "/docs/03-ros2#understanding-nodes") |
| `relevance_score` | Float | RANGE 0.0-1.0 | Qdrant cosine similarity score |

**Validation Rules**:
- `page` must match format `*.md`
- `url` must be valid HTTP URL starting with "/"
- `url` must match Docusaurus route structure
- `relevance_score` must be in range [0.0, 1.0]
- Typically only include citations with `relevance_score` >= 0.7

**Usage**:
- Included in `ChatResponse` API model
- Rendered in frontend with clickable links to course sections
- Sorted by `relevance_score` descending (most relevant first)

**Example**:
```json
{
  "page": "03-ros2.md",
  "section": "Understanding Nodes",
  "url": "/docs/03-ros2#understanding-nodes",
  "relevance_score": 0.89
}
```

**Pydantic Model Definition**:
```python
from pydantic import BaseModel, Field, HttpUrl

class SourceCitation(BaseModel):
    page: str = Field(..., min_length=1, max_length=255, pattern=r".*\.md$")
    section: str = Field(..., min_length=1, max_length=255)
    url: str = Field(..., pattern=r"^/docs/.*")
    relevance_score: float = Field(..., ge=0.0, le=1.0)
```

---

## Entity Relationships Diagram

```
┌─────────────────┐
│  Chat Session   │
│  (Postgres)     │
│                 │
│  PK: id (UUID)  │
│      user_id    │
│      created_at │
│      updated_at │
│      metadata   │
└────────┬────────┘
         │
         │ 1:N
         │
         ▼
┌─────────────────┐
│  Chat Message   │
│  (Postgres)     │
│                 │
│  PK: id (UUID)  │
│  FK: session_id │
│      role       │
│      content    │
│      created_at │
│      metadata   │
└─────────────────┘


┌──────────────────────┐
│ Course Content Chunk │
│ (Qdrant Vector DB)   │
│                      │
│ chunk_id (PK)        │
│ text                 │
│ embedding[1536]      │
│ page                 │
│ section              │
│ url                  │
│ chunk_index          │
│ token_count          │
└──────────┬───────────┘
           │
           │ Used to generate (ephemeral)
           │
           ▼
┌─────────────────────┐
│  Source Citation    │
│  (API Response)     │
│                     │
│  page               │
│  section            │
│  url                │
│  relevance_score    │
└─────────────────────┘
```

**Relationship Notes**:
- Chat Session ← Chat Message: One-to-many (cascading delete)
- Course Content Chunk → Source Citation: Transform relationship (Qdrant search results mapped to citations)
- No direct relationship between Chat messages and Course chunks (decoupled via search)

---

## Data Access Patterns

### Pattern 1: Send Chat Message

**Flow**:
1. Receive user message via POST `/chat`
2. Generate embedding for `message` field
3. Search Qdrant `book_content` collection for top 5 similar chunks
4. Build context from retrieved chunks + optional `selected_text`
5. Query OpenAI Agent SDK with context
6. Agent automatically persists message to Postgres (via SQLAlchemySession)
7. Extract source citations from Qdrant results
8. Return response with citations to frontend

**Entities Involved**: Chat Session, Chat Message, Course Content Chunk, Source Citation

---

### Pattern 2: Retrieve Chat History

**Flow**:
1. Receive GET `/history?session_id={id}`
2. Query Postgres for all messages where `session_id` matches
3. Order by `created_at` ASC (chronological order)
4. Return messages array to frontend

**Entities Involved**: Chat Session, Chat Message

---

### Pattern 3: Embed Course Content (One-time Setup)

**Flow**:
1. Read all Markdown files from `docs/` directory
2. For each file:
   a. Parse Markdown structure (headers, paragraphs)
   b. Chunk content (500-1000 tokens with 100 token overlap)
   c. Generate embeddings using OpenAI `text-embedding-3-small`
   d. Store chunks with metadata in Qdrant collection
3. Create indexes on `book_content` collection

**Entities Involved**: Course Content Chunk

---

### Pattern 4: Search Similar Content

**Flow**:
1. Receive query text
2. Generate embedding for query using same model (`text-embedding-3-small`)
3. Perform vector similarity search in Qdrant:
   - Collection: `book_content`
   - Query vector: generated embedding
   - Distance metric: Cosine
   - Limit: 5 results
   - Threshold: score >= 0.7
4. Return matching chunks with similarity scores

**Entities Involved**: Course Content Chunk

---

## Data Retention and Cleanup

### Chat Data (Postgres)

**Retention Policy**: 90 days

**Cleanup Strategy**:
```sql
DELETE FROM chat_sessions
WHERE updated_at < NOW() - INTERVAL '90 days';
-- Messages cascade delete automatically via foreign key
```

**Schedule**: Run daily at 2:00 AM UTC (low traffic period)

**Implementation**: PostgreSQL cron job or application-level scheduled task

---

### Course Content (Qdrant)

**Retention Policy**: Indefinite (until course content changes)

**Update Strategy**:
- Re-embed only when course content is modified
- Compare file modification timestamps
- Delete old chunks for modified pages
- Insert new chunks with updated embeddings

**Versioning**: Track `created_at` timestamp to identify stale embeddings

---

## Performance Considerations

### Postgres (Chat Data)

**Expected Load**:
- 200 concurrent users during hackathon
- ~10 messages per user per session
- ~2,000 messages per day

**Scaling**:
- Neon free tier: 0.5GB storage, 100 concurrent connections
- Estimated storage: ~50MB for 10,000 messages
- Well within free tier limits

**Optimization**:
- Index on `(session_id, created_at)` for fast history retrieval
- Connection pooling via SQLAlchemy (max 20 connections)

---

### Qdrant (Vector Search)

**Expected Load**:
- 200 concurrent users
- ~2 searches per user per minute (including typing delays)
- ~400 searches per minute = ~7 QPS average
- Peak: ~20 QPS

**Collection Size**:
- ~5,000 chunks (50 pages × 100 chunks per page)
- 1536 dimensions per vector
- ~30MB total storage

**Performance**:
- HNSW index: <50ms search latency for 5k vectors
- Cosine similarity: optimized for normalized embeddings
- Free tier: 1GB storage, sufficient for 30MB + headroom

---

## Migration Strategy

### Initial Setup (One-time)

1. **Create Qdrant Collection**: Run `scripts/setup_qdrant.py`
2. **Embed Course Content**: Run `scripts/embed_content.py` (~2-3 minutes)
3. **Postgres Schema**: Auto-created by OpenAI Agent SDK on first session

**No manual migrations required** - all schema managed automatically.

---

### Content Updates (Iterative)

**When course content changes**:

1. Identify modified files (compare timestamps or git diff)
2. For each modified file:
   - Delete existing chunks: `DELETE WHERE page = '{filename}'`
   - Re-chunk and re-embed updated content
   - Insert new chunks to Qdrant
3. No downtime required (old chunks remain until replaced)

**Script**: `scripts/update_embeddings.py --files 03-ros2.md 05-isaac.md`

---

## Summary

**Total Entities**: 4 (2 persisted, 1 vector-indexed, 1 ephemeral)

**Storage Backends**:
- Postgres (Neon): Chat sessions and messages
- Qdrant: Course content embeddings
- None: Source citations (computed per request)

**Key Design Decisions**:
- OpenAI Agent SDK manages all Postgres schema and migrations
- Qdrant HNSW indexing balances speed and accuracy for semantic search
- 90-day retention balances storage costs with user experience
- Chunking strategy optimized for technical course content (500-1000 tokens)

**Next Steps**: Proceed to `/sp.tasks` for implementation task breakdown
